<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RÉSEAU NEURAL // HACK</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0a0a10;
            --node-off: #333;
            --node-on: #00ccff; /* Bleu électrique */
            --node-start: #00ff00;
            --node-end: #ff0055;
            --cable-width: 6px;
        }

        body {
            background-color: var(--bg-color);
            color: var(--node-on);
            font-family: 'Share Tech Mono', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        /* Fond Technologique */
        body::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: radial-gradient(circle, rgba(0,10,30,0) 0%, rgba(0,0,0,0.9) 100%);
            z-index: 0;
            pointer-events: none;
        }
        
        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        .hack-container {
            position: relative;
            z-index: 1;
            border: 2px solid var(--node-on);
            padding: 20px;
            background: rgba(0, 20, 40, 0.8);
            box-shadow: 0 0 30px rgba(0, 204, 255, 0.15);
            border-radius: 8px;
        }

        h1 {
            margin: 0 0 15px 0;
            text-align: center;
            font-size: 1.8rem;
            text-shadow: 0 0 10px var(--node-on);
            letter-spacing: 2px;
        }

        .info-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 1.1rem;
            border-bottom: 1px solid #334;
            padding-bottom: 10px;
        }

        .timer {
            color: var(--node-end);
            font-weight: bold;
        }

        .grid-container {
            display: grid;
            gap: 2px;
            background: #000;
            padding: 2px;
            border: 1px solid #334;
        }

        .cell {
            width: 60px;
            height: 60px;
            background: #111;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .cell:hover {
            background: #1a1a25;
        }

        /* Les câbles (CSS pur pour la performance) */
        .cell::before, .cell::after, .cell .center {
            content: '';
            position: absolute;
            background: var(--node-off);
            transition: background-color 0.3s;
        }

        .cell .center {
            width: 16px; height: 16px;
            top: 22px; left: 22px;
            border-radius: 50%;
            z-index: 2;
        }

        /* Types de tuyaux (Générés par classes) */
        /* Top */
        .cell.t-top::before { width: var(--cable-width); height: 30px; top: 0; left: 27px; }
        /* Right */
        .cell.t-right::after { width: 30px; height: var(--cable-width); top: 27px; right: 0; }
        /* Bottom (utilise un pseudo-element supplémentaire simulé ou astuce shadow) */
        /* Pour simplifier, on va utiliser des DIVs internes pour les 4 directions */
        
        .pipe {
            position: absolute;
            background: var(--node-off);
            transition: background-color 0.3s;
        }
        .p-top { width: var(--cable-width); height: 30px; top: 0; left: 27px; display: none; }
        .p-right { width: 30px; height: var(--cable-width); top: 27px; right: 0; display: none; }
        .p-bottom { width: var(--cable-width); height: 30px; bottom: 0; left: 27px; display: none; }
        .p-left { width: 30px; height: var(--cable-width); top: 27px; left: 0; display: none; }

        .cell.has-top .p-top { display: block; }
        .cell.has-right .p-right { display: block; }
        .cell.has-bottom .p-bottom { display: block; }
        .cell.has-left .p-left { display: block; }

        /* État Activé (Électricité qui passe) */
        .cell.powered .center,
        .cell.powered .pipe {
            background: var(--node-on);
            box-shadow: 0 0 10px var(--node-on);
        }

        /* Start / End Nodes */
        .cell.start .center { background: var(--node-start); box-shadow: 0 0 15px var(--node-start); width: 20px; height: 20px; top: 20px; left: 20px; }
        .cell.end .center { background: var(--node-end); box-shadow: 0 0 15px var(--node-end); width: 20px; height: 20px; top: 20px; left: 20px; }
        .cell.end.powered .center { background: #fff; box-shadow: 0 0 20px #fff; animation: flash 0.5s infinite; }

        @keyframes flash { 0% { opacity: 0.5; } 100% { opacity: 1; } }

        .overlay-msg {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            z-index: 20;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            color: var(--node-on);
            text-align: center;
        }
        .overlay-msg.visible { visibility: visible; opacity: 1; }
        .msg-fail { color: var(--node-end); }

    </style>
</head>
<body>

    <div class="hack-container">
        <h1>>> PONT RÉSEAU <<</h1>
        
        <div class="info-bar">
            <span>SOURCE: <span style="color:var(--node-start)">ONLINE</span></span>
            <span>CIBLE: <span style="color:var(--node-end)">OFFLINE</span></span>
            <span class="timer" id="timerDisplay">45.0s</span>
        </div>

        <div class="grid-container" id="grid"></div>
        
        <div style="margin-top:10px; font-size:0.8rem; color:#666; text-align:center;">
            [ CLIC ] POUR PIVOTER LES NŒUDS
        </div>
    </div>

    <div id="overlay" class="overlay-msg"></div>

    <script>
        // Configuration
        const ROWS = 6;
        const COLS = 8;
        const TIME_LIMIT = 45.0;

        let grid = []; // Stocke l'état logique { x, y, connections: [t,r,b,l], rotation: 0, type: 'line'|'curve'|'t'|'cross' }
        let startNode = { x: 0, y: 0 };
        let endNode = { x: COLS-1, y: ROWS-1 };
        let timer = TIME_LIMIT;
        let interval = null;
        let isGameOver = false;

        const gridEl = document.getElementById('grid');
        const timerEl = document.getElementById('timerDisplay');
        const overlay = document.getElementById('overlay');

        // Audio
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(freq, type, duration) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        // --- Logique de Génération ---
        
        function initGame() {
            // Configuration CSS de la grille
            gridEl.style.gridTemplateColumns = `repeat(${COLS}, 60px)`;
            gridEl.style.gridTemplateRows = `repeat(${ROWS}, 60px)`;
            
            generateLevel();
            renderGrid();
            startTimer();
            checkPower(); // Vérif initiale
        }

        function generateLevel() {
            grid = [];
            // 1. Initialiser vide
            for(let y=0; y<ROWS; y++) {
                let row = [];
                for(let x=0; x<COLS; x++) {
                    // Types aléatoires pour le remplissage (décoration)
                    // 0=Line, 1=Curve, 2=T-Shape, 3=Cross
                    let rType = Math.random();
                    let conns = [0,0,0,0]; // Top, Right, Bottom, Left
                    
                    if(rType < 0.3) conns = [1,0,1,0]; // Ligne
                    else if(rType < 0.6) conns = [1,1,0,0]; // Courbe
                    else if(rType < 0.9) conns = [1,1,1,0]; // T
                    else conns = [1,1,1,1]; // Cross

                    row.push({ x, y, conns, rotation: Math.floor(Math.random()*4), isPowered: false });
                }
                grid.push(row);
            }

            // 2. Créer un chemin garanti (Snake Algorithm)
            let cx = 0, cy = 0;
            startNode = { x: 0, y: Math.floor(Math.random()*ROWS) };
            cx = startNode.x; cy = startNode.y;
            
            // On s'assure que le départ est connecté à droite
            grid[cy][cx].conns = [0,1,0,0]; 
            grid[cy][cx].rotation = 0; // Reset rotation départ

            let path = [{x:cx, y:cy}];
            
            // Avancer vers la droite jusqu'à la fin
            while(cx < COLS - 1) {
                // Choix direction: 0=Haut, 1=Droite, 2=Bas (On évite Gauche pour progresser)
                let moves = [];
                if(cx < COLS-1) moves.push({dx:1, dy:0, dir:1}); // Droite
                if(cy > 0 && !path.some(p => p.x===cx && p.y===cy-1)) moves.push({dx:0, dy:-1, dir:0}); // Haut
                if(cy < ROWS-1 && !path.some(p => p.x===cx && p.y===cy+1)) moves.push({dx:0, dy:1, dir:2}); // Bas

                // On favorise la droite pour finir
                if(Math.random() > 0.6 && moves.some(m => m.dx === 1)) {
                    moves = moves.filter(m => m.dx === 1);
                }

                let move = moves[Math.floor(Math.random() * moves.length)];
                
                // Connecter le nœud actuel vers la nouvelle direction
                // move.dir : 0=Top, 1=Right, 2=Bottom
                grid[cy][cx].conns[move.dir] = 1;

                cx += move.dx;
                cy += move.dy;
                path.push({x:cx, y:cy});

                // Connecter le nouveau nœud vers l'ancienne direction (opposée)
                // Opposé de Top(0) est Bottom(2), Right(1) est Left(3), Bottom(2) est Top(0)
                let cameFrom = (move.dir + 2) % 4;
                grid[cy][cx].conns = [0,0,0,0]; // Reset du noeud sur le chemin
                grid[cy][cx].conns[cameFrom] = 1;
            }

            endNode = { x: cx, y: cy };
            
            // 3. Brouiller les rotations
            for(let y=0; y<ROWS; y++) {
                for(let x=0; x<COLS; x++) {
                    // Ne pas toucher start et end pour faciliter le début visuel
                    if((x===startNode.x && y===startNode.y) || (x===endNode.x && y===endNode.y)) continue;
                    
                    // Rotation aléatoire
                    let rots = Math.floor(Math.random() * 4);
                    for(let r=0; r<rots; r++) rotateNodeLogic(grid[y][x]);
                }
            }
        }

        function rotateNodeLogic(node) {
            // Décale le tableau [T, R, B, L] -> [L, T, R, B]
            let last = node.conns.pop();
            node.conns.unshift(last);
            node.rotation = (node.rotation + 90) % 360;
        }

        // --- Rendu ---

        function renderGrid() {
            gridEl.innerHTML = '';
            for(let y=0; y<ROWS; y++) {
                for(let x=0; x<COLS; x++) {
                    const node = grid[y][x];
                    const el = document.createElement('div');
                    el.className = 'cell';
                    el.id = `cell_${x}_${y}`;
                    
                    // Ajouter les tuyaux visuels
                    const pipes = ['p-top', 'p-right', 'p-bottom', 'p-left'];
                    for(let i=0; i<4; i++) {
                        if(node.conns[i]) el.classList.add(hasName(i));
                        let p = document.createElement('div');
                        p.className = `pipe ${pipes[i]}`;
                        el.appendChild(p);
                    }

                    let center = document.createElement('div');
                    center.className = 'center';
                    el.appendChild(center);

                    if(x===startNode.x && y===startNode.y) el.classList.add('start', 'powered');
                    if(x===endNode.x && y===endNode.y) el.classList.add('end');
                    if(node.isPowered) el.classList.add('powered');

                    el.addEventListener('click', () => handleClick(x, y));
                    // Désactiver le menu contextuel (clic droit)
                    el.addEventListener('contextmenu', (e) => { e.preventDefault(); handleClick(x, y); });

                    gridEl.appendChild(el);
                }
            }
        }

        function hasName(idx) {
            return ['has-top', 'has-right', 'has-bottom', 'has-left'][idx];
        }

        // --- Gameplay ---

        function handleClick(x, y) {
            if(isGameOver) return;
            
            // On ne tourne pas le start ni le end (option de difficulté)
            // if((x===startNode.x && y===startNode.y) || (x===endNode.x && y===endNode.y)) return;

            playTone(400, 'triangle', 0.05);
            
            // Logique
            rotateNodeLogic(grid[y][x]);
            
            // Visuel (sans re-rendu total pour perf, on update juste les classes)
            updateCellVisuals(x, y);
            
            checkPower();
        }

        function updateCellVisuals(x, y) {
            const node = grid[y][x];
            const el = document.getElementById(`cell_${x}_${y}`);
            
            // Reset classes
            el.classList.remove('has-top', 'has-right', 'has-bottom', 'has-left');
            
            if(node.conns[0]) el.classList.add('has-top');
            if(node.conns[1]) el.classList.add('has-right');
            if(node.conns[2]) el.classList.add('has-bottom');
            if(node.conns[3]) el.classList.add('has-left');
        }

        // Algorithme de propagation du courant (BFS / Flood Fill)
        function checkPower() {
            // Reset power
            for(let y=0; y<ROWS; y++) {
                for(let x=0; x<COLS; x++) {
                    grid[y][x].isPowered = false;
                    document.getElementById(`cell_${x}_${y}`).classList.remove('powered');
                }
            }

            // Start is always powered
            let queue = [startNode];
            grid[startNode.y][startNode.x].isPowered = true;
            document.getElementById(`cell_${startNode.x}_${startNode.y}`).classList.add('powered');

            while(queue.length > 0) {
                let curr = queue.shift();
                let cx = curr.x;
                let cy = curr.y;
                let currentNode = grid[cy][cx];

                // Vérifier les 4 voisins
                // Top (0) -> Voisin doit avoir Bottom (2)
                if(currentNode.conns[0] && cy > 0) {
                    let neighbor = grid[cy-1][cx];
                    if(neighbor.conns[2] && !neighbor.isPowered) {
                        neighbor.isPowered = true;
                        document.getElementById(`cell_${cx}_${cy-1}`).classList.add('powered');
                        queue.push({x:cx, y:cy-1});
                    }
                }
                // Right (1) -> Voisin doit avoir Left (3)
                if(currentNode.conns[1] && cx < COLS-1) {
                    let neighbor = grid[cy][cx+1];
                    if(neighbor.conns[3] && !neighbor.isPowered) {
                        neighbor.isPowered = true;
                        document.getElementById(`cell_${cx+1}_${cy}`).classList.add('powered');
                        queue.push({x:cx+1, y:cy});
                    }
                }
                // Bottom (2) -> Voisin doit avoir Top (0)
                if(currentNode.conns[2] && cy < ROWS-1) {
                    let neighbor = grid[cy+1][cx];
                    if(neighbor.conns[0] && !neighbor.isPowered) {
                        neighbor.isPowered = true;
                        document.getElementById(`cell_${cx}_${cy+1}`).classList.add('powered');
                        queue.push({x:cx, y:cy+1});
                    }
                }
                // Left (3) -> Voisin doit avoir Right (1)
                if(currentNode.conns[3] && cx > 0) {
                    let neighbor = grid[cy][cx-1];
                    if(neighbor.conns[1] && !neighbor.isPowered) {
                        neighbor.isPowered = true;
                        document.getElementById(`cell_${cx-1}_${cy}`).classList.add('powered');
                        queue.push({x:cx-1, y:cy});
                    }
                }
            }

            // Win Condition
            if(grid[endNode.y][endNode.x].isPowered) {
                winGame();
            }
        }

        function startTimer() {
            interval = setInterval(() => {
                timer -= 0.1;
                timerEl.textContent = timer.toFixed(1) + "s";
                if(timer <= 10.0) timerEl.style.color = "#ff0000";
                
                if(timer <= 0) {
                    gameOver();
                }
            }, 100);
        }

        async function winGame() {
            if(isGameOver) return;
            isGameOver = true;
            clearInterval(interval);
            playTone(1000, 'square', 0.2);
            
            overlay.innerHTML = `
                <div style="color:#00ff00; text-shadow:0 0 20px #00ff00;">RÉSEAU RÉTABLI</div>
                <div style="font-size:1rem; color:#fff; margin-top:20px;">ROUTAGE DES DONNÉES...</div>
            `;
            overlay.classList.add('visible');

            try {
                const response = await fetch('/api/get-access', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();

                if (data.success && data.redirect) {
                    sessionStorage.setItem('hack_token', data.token);
                    setTimeout(() => { window.location.href = data.redirect; }, 2000);
                }
            } catch (e) { console.error(e); }
        }

        function gameOver() {
            if(isGameOver) return;
            isGameOver = true;
            clearInterval(interval);
            playTone(150, 'sawtooth', 0.5);
            
            overlay.innerHTML = `
                <div class="msg-fail">CONNEXION PERDUE</div>
                <div style="font-size:1rem; color:#fff; margin-top:20px;">TIMEOUT</div>
            `;
            overlay.classList.add('visible');
            
            setTimeout(() => { window.location.href = '/access-denied.html'; }, 2000);
        }

        initGame();

    </script>
</body>
</html>