<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UPLINK SATELLITE // HACK</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #000510;
            --hud-color: #00ffff;
            --target-color: #ff0055;
            --lock-color: #00ff00;
            --grid-color: rgba(0, 255, 255, 0.1);
        }

        body {
            background-color: var(--bg-color);
            color: var(--hud-color);
            font-family: 'Share Tech Mono', monospace;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: none; 
        }

        body::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: radial-gradient(circle, rgba(0,20,40,0) 0%, rgba(0,0,0,0.8) 100%);
            z-index: 5;
            pointer-events: none;
        }

        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 6;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        .hud-container {
            position: relative;
            width: 800px;
            height: 600px;
            border: 2px solid var(--hud-color);
            background: rgba(0, 10, 20, 0.5);
            box-shadow: 0 0 20px var(--hud-color);
            overflow: hidden;
        }

        .grid-background {
            position: absolute;
            width: 200%;
            height: 200%;
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 50px 50px;
            transform: perspective(500px) rotateX(20deg) translateY(-100px);
            animation: gridScroll 10s linear infinite;
            z-index: 0;
        }

        @keyframes gridScroll {
            0% { background-position: 0 0; }
            100% { background-position: 0 50px; }
        }

        .target-dot {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid var(--target-color);
            border-radius: 50%;
            background: rgba(255, 0, 85, 0.2);
            box-shadow: 0 0 15px var(--target-color);
            transform: translate(-50%, -50%);
            z-index: 2;
            transition: border-color 0.1s, background-color 0.1s;
        }
        .target-dot::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: var(--target-color);
            transform: translate(-50%, -50%);
        }

        .reticle {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 2px dashed var(--hud-color);
            transform: translate(-50%, -50%);
            z-index: 3;
            pointer-events: none; 
            box-shadow: 0 0 10px var(--hud-color);
            transition: width 0.2s, height 0.2s, border-color 0.2s;
        }
        
        .reticle.locked {
            border-color: var(--lock-color);
            border-style: solid;
            box-shadow: 0 0 20px var(--lock-color);
            width: 70px;
            height: 70px;
        }

        .reticle::before, .reticle::after {
            content: '';
            position: absolute;
            background: var(--hud-color);
        }
        .reticle::before { top: 50%; left: 0; width: 100%; height: 1px; }
        .reticle::after { top: 0; left: 50%; width: 1px; height: 100%; }

        .hud-header {
            position: absolute;
            top: 20px; left: 20px;
            z-index: 4;
            font-size: 1.2rem;
            text-shadow: 0 0 5px var(--hud-color);
        }

        .progress-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 20px;
            border: 2px solid var(--hud-color);
            background: rgba(0,0,0,0.5);
            z-index: 4;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background: var(--hud-color);
            transition: width 0.1s linear;
            box-shadow: 0 0 10px var(--hud-color);
        }

        .status-text {
            position: absolute;
            bottom: 60px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            text-transform: uppercase;
            z-index: 4;
        }

        .overlay-msg {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            z-index: 20;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            color: var(--lock-color);
        }
        .overlay-msg.visible { visibility: visible; opacity: 1; }
        .msg-fail { color: var(--target-color); }

    </style>
</head>
<body>

    <div class="hud-container" id="gameArea">
        <div class="grid-background"></div>
        
        <div class="hud-header">
            SIGNAL: <span id="signal-id">Unknown</span><br>
            DISTANCE: <span id="dist-val">Calculating...</span>
        </div>

        <div class="target-dot" id="target"></div>
        <div class="reticle" id="reticle"></div>

        <div class="status-text" id="status">ACQUISITION EN COURS...</div>

        <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>

        <div id="overlay" class="overlay-msg"></div>
    </div>

    <script>
        const config = {
            targetSpeed: 3.5,      
            changeDirRate: 0.05, 
            lockRadius: 50,      
            fillRate: 0.4,       
            drainRate: 0.2       
        };

        let state = {
            mouseX: 400,
            mouseY: 300,
            targetX: 400,
            targetY: 300,
            velocityX: 2,
            velocityY: 2,
            progress: 0,
            isLocked: false,
            gameOver: false,
            frameId: null
        };

        const gameArea = document.getElementById('gameArea');
        const target = document.getElementById('target');
        const reticle = document.getElementById('reticle');
        const progressBar = document.getElementById('progressBar');
        const statusText = document.getElementById('status');
        const distDisplay = document.getElementById('dist-val');
        const signalDisplay = document.getElementById('signal-id');
        const overlay = document.getElementById('overlay');

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playTone(freq, type, duration) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function initGame() {
            signalDisplay.innerText = "SAT-" + Math.floor(Math.random()*9000 + 1000);
            gameArea.addEventListener('mousemove', (e) => {
                const rect = gameArea.getBoundingClientRect();
                state.mouseX = e.clientX - rect.left;
                state.mouseY = e.clientY - rect.top;
            });
            updateLoop();
        }

        function updateLoop() {
            if (state.gameOver) return;

            if (Math.random() < config.changeDirRate) {
                state.velocityX += (Math.random() - 0.5) * 2;
                state.velocityY += (Math.random() - 0.5) * 2;
            }

            // Limite vitesse
            const speed = Math.sqrt(state.velocityX**2 + state.velocityY**2);
            if (speed > config.targetSpeed) {
                state.velocityX = (state.velocityX / speed) * config.targetSpeed;
                state.velocityY = (state.velocityY / speed) * config.targetSpeed;
            }

            state.targetX += state.velocityX;
            state.targetY += state.velocityY;

            // Rebond bords
            const w = gameArea.clientWidth;
            const h = gameArea.clientHeight;
            const pad = 30;

            if (state.targetX < pad || state.targetX > w - pad) state.velocityX *= -1;
            if (state.targetY < pad || state.targetY > h - pad) state.velocityY *= -1;

            // Clamp
            state.targetX = Math.max(pad, Math.min(w - pad, state.targetX));
            state.targetY = Math.max(pad, Math.min(h - pad, state.targetY));

            // Calcul Distance
            const dx = state.mouseX - state.targetX;
            const dy = state.mouseY - state.targetY;
            const distance = Math.sqrt(dx*dx + dy*dy);

            distDisplay.innerText = Math.floor(distance) + "m";

            // Check Lock
            if (distance < config.lockRadius) {
                if (!state.isLocked) {
                    state.isLocked = true;
                    reticle.classList.add('locked');
                    statusText.innerText = "VERROUILLAGE...";
                    statusText.style.color = "#00ff00";
                    target.style.borderColor = "#00ff00";
                }
                state.progress += config.fillRate;
                if (Math.random() > 0.8) playTone(800, 'square', 0.05); // Bruit de lock
            } else {
                if (state.isLocked) {
                    state.isLocked = false;
                    reticle.classList.remove('locked');
                    statusText.innerText = "SIGNAL PERDU";
                    statusText.style.color = "var(--hud-color)";
                    target.style.borderColor = "var(--target-color)";
                }
                state.progress -= config.drainRate;
            }

            state.progress = Math.max(0, Math.min(100, state.progress));
            progressBar.style.width = state.progress + "%";

            // Update positions visuelles
            target.style.left = state.targetX + "px";
            target.style.top = state.targetY + "px";
            reticle.style.left = state.mouseX + "px";
            reticle.style.top = state.mouseY + "px";

            if (state.progress >= 100) {
                winGame();
            } else {
                state.frameId = requestAnimationFrame(updateLoop);
            }
        }

        async function winGame() {
            state.gameOver = true;
            cancelAnimationFrame(state.frameId);
            
            playTone(1200, 'sine', 0.5);
            overlay.innerHTML = `
                <div>LIAISON ÉTABLIE</div>
                <div style="font-size: 1rem; margin-top:20px; color:#fff;">TÉLÉCHARGEMENT...</div>
            `;
            overlay.classList.add('visible');

            try {
                const response = await fetch('/api/get-access', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();

                if (data.success && data.redirect) {
                    sessionStorage.setItem('hack_token', data.token);
                    setTimeout(() => {
                        window.location.href = data.redirect;
                    }, 2000);
                }
            } catch (error) {
                overlay.innerHTML = `<div class="msg-fail">ERREUR FATALE</div>`;
            }
        }

        initGame();

    </script>
</body>
</html>